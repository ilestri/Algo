import{p as n}from"./steps-C4T7tiBa.js";const c=["l ← 0, r ← n-1","while l ≤ r","  m ← ⌊(l + r)/2⌋","  if a[m] == x return m","  else if a[m] < x then l ← m+1","  else r ← m-1"];function*o(l,i){let a=0,r=l.length-1;for(yield{type:"init",l:a,r};a<=r;){yield{type:"range",l:a,r};const e=a+r>>1;if(yield{type:"mid",m:e},yield{type:"compare",m:e},l[e]===i){yield{type:"found",m:e};break}else l[e]<i?(a=e+1,yield{type:"moveL",l:a,r}):(r=e-1,yield{type:"moveR",l:a,r})}}function*t({array:l,x:i}){for(const a of o(l,i))switch(a.type){case"range":yield{type:"highlightRange",payload:{l:a.l,r:a.r},pc:[2],explain:"검색 범위"};break;case"compare":yield{type:"compare",payload:{i:a.m},pc:[3,4],explain:"중간값 비교"};break;case"found":yield{type:"visit",payload:{i:a.m},pc:[4],explain:"발견"};return;case"moveL":yield{type:"highlightRange",payload:{l:a.l,r:a.r},pc:[5],explain:"오른쪽 절반"};break;case"moveR":yield{type:"highlightRange",payload:{l:a.l,r:a.r},pc:[6],explain:"왼쪽 절반"};break}}function p(l,i,a){const r={...l,highlight:[],range:l.range};return i.type==="highlightRange"?r.range={l:i.payload.l,r:i.payload.r}:i.type==="compare"?(r.highlight=[i.payload.i],a.compares++):i.type==="visit"&&(r.found=i.payload.i),r}function y({array:l}){const i=l&&l.length?l:[1,3,4,5,7,8,10],a=i[Math.floor(i.length/2)];return{input:{array:i,x:a},state:{array:[...i],highlight:[],range:{l:0,r:i.length-1},found:null}}}const m={canvas:"array",init:y,generate:t,apply:p,pseudocode:c,code:t.toString()};function g(l){const i=l.array.slice(),a=l.key,r=[];for(const e of o(i,a))switch(e.type){case"init":n(r,"pointer",{name:"l",index:e.l},[1],`좌측 경계 초기화 l=${e.l}`),n(r,"pointer",{name:"r",index:e.r},[1],`우측 경계 초기화 r=${e.r}`),n(r,"highlightRange",{l:e.l,r:e.r},[1],`탐색 구간 초기화 [${e.l}, ${e.r}]`);break;case"range":n(r,"highlightRange",{l:e.l,r:e.r},[2],`현재 구간 [${e.l}, ${e.r}]`);break;case"mid":n(r,"pointer",{name:"m",index:e.m},[3],`중앙 인덱스 설정 m=${e.m}`);break;case"compare":n(r,"compare",{i:e.m},[3,4],`중앙 인덱스 ${e.m} 값과 키 비교`);break;case"found":n(r,"visit",{i:e.m},[4],`키 발견: 인덱스 ${e.m}`);break;case"moveL":n(r,"pointer",{name:"l",index:e.l},[5],`좌측 경계 이동: l=${e.l}`);break;case"moveR":n(r,"pointer",{name:"r",index:e.r},[6],`우측 경계 이동: r=${e.r}`);break}return r}const h={id:"searching/binary",category:"searching",title:"이진 탐색 (Binary Search)",pseudocode:["l ← 0; r ← n-1","while l ≤ r:","  m ← ⌊(l+r)/2⌋","  if A[m] == key: return m","  else if A[m] < key: l ← m+1","  else: r ← m-1"],complexity:{best:"O(1)",average:"O(log n)",worst:"O(log n)",space:"O(1)"},defaultInput:{array:[1,3,5,7,9,11,13],key:7},normalizeInput:l=>{const i=Array.isArray(l?.array)?l.array.map(r=>Number(r)).filter(r=>Number.isFinite(r)):[],a=Number(l?.key);return{array:i.slice(0,5e3),key:Number.isFinite(a)?a:0}}};export{m as adapter,p as apply,h as descriptor,t as generate,y as init,c as pseudocode,g as stepsOf};
