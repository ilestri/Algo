import{p as o}from"./steps-C4T7tiBa.js";function O(i){const r=(i.keys||[]).slice(),s=[];function e(t,n,c){o(s,"visit",{value:t},n,c)}for(const t of r)e(t,[1],`키 ${t} 삽입 탐색`),o(s,"insert",{key:t},[1],`키 ${t} 삽입`);if(Number.isFinite(i.search)){const t=i.search;e(t,[2],`키 ${t} 검색`)}if(Number.isFinite(i.remove)){const t=i.remove;o(s,"delete",{key:t},[3],`키 ${t} 삭제`)}return s}const $={id:"tree/bst",category:"tree",title:"이진 탐색 트리 (BST)",pseudocode:["insert(T, key)","search(T, key)","delete(T, key)"],complexity:{best:"O(log n)",average:"O(log n)",worst:"O(n)",space:"O(h)"},defaultInput:{keys:[7,3,9,1,5,8,10],search:5},normalizeInput:i=>{const r=Array.isArray(i?.keys)?i.keys.map(t=>Number(t)).filter(t=>Number.isFinite(t)):[],s=Number(i?.search),e=Number(i?.remove);return{keys:r.slice(0,1e3),search:Number.isFinite(s)?s:void 0,remove:Number.isFinite(e)?e:void 0}}},p=["if root = ∅ then root ← new(key)","cur ← root","while true","  if key < cur.key","    if cur.left = ∅ then cur.left ← new(key); break","    else cur ← cur.left","  else","    if cur.right = ∅ then cur.right ← new(key); break","    else cur ← cur.right"];let d=1;function y(i,r,s){if(!i)return o(s,"insert",{value:r},[1],"루트 삽입"),{id:d++,value:r};let e=i;for(o(s,"visit",{id:e.id},[2,3],`노드 방문 ${e.value}`);;)if(r<e.value)if(o(s,"compare",{cur:e.value,key:r},[4],"왼쪽 비교"),e.left)e=e.left,o(s,"visit",{id:e.id},[6],"이동");else{e.left={id:d++,value:r},o(s,"insert",{parent:e.id,side:"L",value:r},[5],"왼쪽 삽입");break}else if(o(s,"compare",{cur:e.value,key:r},[7],"오른쪽 비교"),e.right)e=e.right,o(s,"visit",{id:e.id},[9],"이동");else{e.right={id:d++,value:r},o(s,"insert",{parent:e.id,side:"R",value:r},[8],"오른쪽 삽입");break}return i}function b(i,r=800,s=240){const e=[],t=[],n={};function c(u,l){if(!u)return;const g=n[l]=(n[l]??0)+1,m=l+1,v=r/(Math.pow(2,l)+1),h=s/6,a=v*g,f=h*m;e.push({id:u.id,value:u.value,x:a,y:f,highlight:!1}),u.left&&(t.push({x1:a,y1:f,x2:a-v/2,y2:f+h}),c(u.left,l+1)),u.right&&(t.push({x1:a,y1:f,x2:a+v/2,y2:f+h}),c(u.right,l+1))}return c(i,0),{nodes:e,edges:t}}function k({seq:i}){const r=i&&i.length?i:[8,3,10,1,6,14],s=[];let e;d=1;for(const c of r)e=y(e,c,s);const{nodes:t,edges:n}=b(e);return{input:r,state:{nodes:t,edges:n,root:e}}}function*x(i){const r=[];let s;d=1;for(const e of i)s=y(s,e,r);for(const e of r)yield e}function N(i,r,s){const e={...i,nodes:i.nodes.map(t=>({...t}))};if(r.type==="visit"){const t=e.nodes.find(n=>n.id===r.payload.id);t&&(t.highlight=!0)}else r.type;return e}const T={canvas:"tree",init:k,generate:x,apply:N,pseudocode:p,code:y.toString()};export{T as adapter,N as apply,$ as descriptor,x as generate,k as init,p as pseudocode,O as stepsOf};
