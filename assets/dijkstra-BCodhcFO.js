import{normalizeGraphInput as w}from"./utils-BrxOh9X6.js";import{p as n}from"./steps-C4T7tiBa.js";class g{constructor(t){this.compare=t}heap=[];swap(t,e){[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]]}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.compare(this.heap[t],this.heap[e])>=0)break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length-1;for(;t*2+1<=e;){const a=t*2+1,o=t*2+2;let s=t;if(a<=e&&this.compare(this.heap[a],this.heap[s])<0&&(s=a),o<=e&&this.compare(this.heap[o],this.heap[s])<0&&(s=o),s===t)break;this.swap(t,s),t=s}}push(t){this.heap.push(t),this.bubbleUp(this.heap.length-1)}pop(){if(!this.heap.length)return;const t=this.heap[0],e=this.heap.pop();return this.heap.length&&(this.heap[0]=e,this.bubbleDown(0)),t}get length(){return this.heap.length}}function m(l){const{n:t,adj:e,start:a}=l,o=Number.POSITIVE_INFINITY,s=Array(t).fill(o),c=Array(t).fill(!1),i=[],u=new g((h,p)=>h.d-p.d);for(s[a]=0,u.push({d:0,u:a}),n(i,"enqueue",{v:a},[1],`시작 정점 ${a} 거리 0, PQ 삽입`);u.length;){const h=u.pop();if(n(i,"dequeue",{v:h.u},[3],`정점 ${h.u} 추출`),!c[h.u]){c[h.u]=!0;for(const{v:p,w:f}of e[h.u]||[]){const r=(s[h.u]===o?0:s[h.u])+(f??1);n(i,"compare",{u:h.u,v:p,w:f},[4],`간선 ${h.u}→${p} 이완 검사`),s[p]>r&&(s[p]=r,n(i,"relax",{v:p,dist:r},[5],`정점 ${p} 거리 갱신: ${r}`),u.push({d:r,u:p}),n(i,"enqueue",{v:p},[5],`정점 ${p} PQ 삽입`))}}}return i}const v={id:"graph/dijkstra",category:"graph",title:"다익스트라 (Dijkstra)",pseudocode:["dist[s] ← 0; PQ ← {(0,s)}","while PQ not empty:","  (d,u) ← extract-min","  for (u,v,w) in adj[u]:","    if dist[v] > d + w: dist[v] ← d+w"],complexity:{best:"O((V+E) log V)",average:"O((V+E) log V)",worst:"O((V+E) log V)",space:"O(V)"},defaultInput:{n:5,adj:{0:[{v:1,w:2},{v:2,w:5}],1:[{v:3,w:1}],2:[{v:4,w:2}]},start:0},normalizeInput:w},I="diff";export{v as descriptor,I as snapshotStrategy,m as stepsOf};
