import{m as h,p as u}from"./steps-C4T7tiBa.js";import{n as $}from"./normalize-array-input-DMzkLNrw.js";function A(m){const s=m.array.slice(),a=[];function p(n,o,g){u(a,"highlightRange",{l:n,r:g},[6],`병합 구간 [${n}, ${g}]`);const i=s.slice(n,o+1),l=s.slice(o+1,g+1);let t=0,r=0,e=n;for(;t<i.length&&r<l.length;)u(a,"compare",{i:n+t,j:o+1+r},[6],`인덱스 ${n+t}와 ${o+1+r} 비교`),i[t]<=l[r]?(s[e]=i[t],u(a,"setValue",{index:e,value:i[t]},[6],`A[${e}] ← ${i[t]}`),t++):(s[e]=l[r],u(a,"setValue",{index:e,value:l[r]},[6],`A[${e}] ← ${l[r]}`),r++),e++;for(;t<i.length;)s[e]=i[t],u(a,"setValue",{index:e,value:i[t]},[6],`A[${e}] ← ${i[t]}`),t++,e++;for(;r<l.length;)s[e]=l[r],u(a,"setValue",{index:e,value:l[r]},[6],`A[${e}] ← ${l[r]}`),r++,e++}function c(n,o){if(n>=o)return;const g=n+o>>1;c(n,g),c(g+1,o),p(n,g,o)}return c(0,s.length-1),h(a,s.length,[1]),a}const x={id:"sorting/merge",category:"sorting",title:"병합 정렬 (Merge Sort)",pseudocode:["procedure mergeSort(A, l, r)","  if l ≥ r: return","  m ← ⌊(l+r)/2⌋","  mergeSort(A, l, m)","  mergeSort(A, m+1, r)","  merge(A, l, m, r)"],complexity:{best:"O(n log n)",average:"O(n log n)",worst:"O(n log n)",space:"O(n)"},defaultInput:{array:[10,3,7,2,5,8]},normalizeInput:$};export{x as descriptor,A as stepsOf};
